{"ast":null,"code":"import { tzOffset } from \"../tzOffset/index.js\";\nexport class TZDateMini extends Date {\n  //#region static\n\n  constructor(...args) {\n    super();\n    if (args.length > 1 && typeof args[args.length - 1] === \"string\") {\n      this.timeZone = args.pop();\n    }\n    this.internal = new Date();\n    if (isNaN(tzOffset(this.timeZone, this))) {\n      this.setTime(NaN);\n    } else {\n      if (!args.length) {\n        this.setTime(Date.now());\n      } else if (typeof args[0] === \"number\" && (args.length === 1 || args.length === 2 && typeof args[1] !== \"number\")) {\n        this.setTime(args[0]);\n      } else if (typeof args[0] === \"string\") {\n        this.setTime(+new Date(args[0]));\n      } else if (args[0] instanceof Date) {\n        this.setTime(+args[0]);\n      } else {\n        this.setTime(+new Date(...args));\n        adjustToSystemTZ(this, NaN);\n        syncToInternal(this);\n      }\n    }\n  }\n  static tz(tz, ...args) {\n    return args.length ? new TZDateMini(...args, tz) : new TZDateMini(Date.now(), tz);\n  }\n\n  //#endregion\n\n  //#region time zone\n\n  withTimeZone(timeZone) {\n    return new TZDateMini(+this, timeZone);\n  }\n  getTimezoneOffset() {\n    const offset = -tzOffset(this.timeZone, this);\n    // Remove the seconds offset\n    // use Math.floor for negative GMT timezones and Math.ceil for positive GMT timezones.\n    return offset > 0 ? Math.floor(offset) : Math.ceil(offset);\n  }\n\n  //#endregion\n\n  //#region time\n\n  setTime(time) {\n    Date.prototype.setTime.apply(this, arguments);\n    syncToInternal(this);\n    return +this;\n  }\n\n  //#endregion\n\n  //#region date-fns integration\n\n  [Symbol.for(\"constructDateFrom\")](date) {\n    return new TZDateMini(+new Date(date), this.timeZone);\n  }\n\n  //#endregion\n}\n\n// Assign getters and setters\nconst re = /^(get|set)(?!UTC)/;\nObject.getOwnPropertyNames(Date.prototype).forEach(method => {\n  if (!re.test(method)) return;\n  const utcMethod = method.replace(re, \"$1UTC\");\n  // Filter out methods without UTC counterparts\n  if (!TZDateMini.prototype[utcMethod]) return;\n  if (method.startsWith(\"get\")) {\n    // Delegate to internal date's UTC method\n    TZDateMini.prototype[method] = function () {\n      return this.internal[utcMethod]();\n    };\n  } else {\n    // Assign regular setter\n    TZDateMini.prototype[method] = function () {\n      Date.prototype[utcMethod].apply(this.internal, arguments);\n      syncFromInternal(this);\n      return +this;\n    };\n\n    // Assign UTC setter\n    TZDateMini.prototype[utcMethod] = function () {\n      Date.prototype[utcMethod].apply(this, arguments);\n      syncToInternal(this);\n      return +this;\n    };\n  }\n});\n\n/**\n * Function syncs time to internal date, applying the time zone offset.\n *\n * @param {Date} date - Date to sync\n */\nfunction syncToInternal(date) {\n  date.internal.setTime(+date);\n  date.internal.setUTCSeconds(date.internal.getUTCSeconds() - Math.round(-tzOffset(date.timeZone, date) * 60));\n}\n\n/**\n * Function syncs the internal date UTC values to the date. It allows to get\n * accurate timestamp value.\n *\n * @param {Date} date - The date to sync\n */\nfunction syncFromInternal(date) {\n  // First we transpose the internal values\n  Date.prototype.setFullYear.call(date, date.internal.getUTCFullYear(), date.internal.getUTCMonth(), date.internal.getUTCDate());\n  Date.prototype.setHours.call(date, date.internal.getUTCHours(), date.internal.getUTCMinutes(), date.internal.getUTCSeconds(), date.internal.getUTCMilliseconds());\n\n  // Now we have to adjust the date to the system time zone\n  adjustToSystemTZ(date);\n}\n\n/**\n * Function adjusts the date to the system time zone. It uses the time zone\n * differences to calculate the offset and adjust the date.\n *\n * @param {Date} date - Date to adjust\n */\nfunction adjustToSystemTZ(date) {\n  // Save the time zone offset before all the adjustments\n  const baseOffset = tzOffset(date.timeZone, date);\n  // Remove the seconds offset\n  // use Math.floor for negative GMT timezones and Math.ceil for positive GMT timezones.\n  const offset = baseOffset > 0 ? Math.floor(baseOffset) : Math.ceil(baseOffset);\n  //#region System DST adjustment\n\n  // The biggest problem with using the system time zone is that when we create\n  // a date from internal values stored in UTC, the system time zone might end\n  // up on the DST hour:\n  //\n  //   $ TZ=America/New_York node\n  //   > new Date(2020, 2, 8, 1).toString()\n  //   'Sun Mar 08 2020 01:00:00 GMT-0500 (Eastern Standard Time)'\n  //   > new Date(2020, 2, 8, 2).toString()\n  //   'Sun Mar 08 2020 03:00:00 GMT-0400 (Eastern Daylight Time)'\n  //   > new Date(2020, 2, 8, 3).toString()\n  //   'Sun Mar 08 2020 03:00:00 GMT-0400 (Eastern Daylight Time)'\n  //   > new Date(2020, 2, 8, 4).toString()\n  //   'Sun Mar 08 2020 04:00:00 GMT-0400 (Eastern Daylight Time)'\n  //\n  // Here we get the same hour for both 2 and 3, because the system time zone\n  // has DST beginning at 8 March 2020, 2 a.m. and jumps to 3 a.m. So we have\n  // to adjust the internal date to reflect that.\n  //\n  // However we want to adjust only if that's the DST hour the change happenes,\n  // not the hour where DST moves to.\n\n  // We calculate the previous hour to see if the time zone offset has changed\n  // and we have landed on the DST hour.\n  const prevHour = new Date(+date);\n  // We use UTC methods here as we don't want to land on the same hour again\n  // in case of DST.\n  prevHour.setUTCHours(prevHour.getUTCHours() - 1);\n\n  // Calculate if we are on the system DST hour.\n  const systemOffset = -new Date(+date).getTimezoneOffset();\n  const prevHourSystemOffset = -new Date(+prevHour).getTimezoneOffset();\n  const systemDSTChange = systemOffset - prevHourSystemOffset;\n  // Detect the DST shift. System DST change will occur both on\n  const dstShift = Date.prototype.getHours.apply(date) !== date.internal.getUTCHours();\n\n  // Move the internal date when we are on the system DST hour.\n  if (systemDSTChange && dstShift) date.internal.setUTCMinutes(date.internal.getUTCMinutes() + systemDSTChange);\n\n  //#endregion\n\n  //#region System diff adjustment\n\n  // Now we need to adjust the date, since we just applied internal values.\n  // We need to calculate the difference between the system and date time zones\n  // and apply it to the date.\n\n  const offsetDiff = systemOffset - offset;\n  if (offsetDiff) Date.prototype.setUTCMinutes.call(date, Date.prototype.getUTCMinutes.call(date) + offsetDiff);\n\n  //#endregion\n\n  //#region Seconds System diff adjustment\n\n  const systemDate = new Date(+date);\n  // Set the UTC seconds to 0 to isolate the timezone offset in seconds.\n  systemDate.setUTCSeconds(0);\n  // For negative systemOffset, invert the seconds.\n  const systemSecondsOffset = systemOffset > 0 ? systemDate.getSeconds() : (systemDate.getSeconds() - 60) % 60;\n\n  // Calculate the seconds offset based on the timezone offset.\n  const secondsOffset = Math.round(-(tzOffset(date.timeZone, date) * 60)) % 60;\n  if (secondsOffset || systemSecondsOffset) {\n    date.internal.setUTCSeconds(date.internal.getUTCSeconds() + secondsOffset);\n    Date.prototype.setUTCSeconds.call(date, Date.prototype.getUTCSeconds.call(date) + secondsOffset + systemSecondsOffset);\n  }\n\n  //#endregion\n\n  //#region Post-adjustment DST fix\n\n  const postBaseOffset = tzOffset(date.timeZone, date);\n  // Remove the seconds offset\n  // use Math.floor for negative GMT timezones and Math.ceil for positive GMT timezones.\n  const postOffset = postBaseOffset > 0 ? Math.floor(postBaseOffset) : Math.ceil(postBaseOffset);\n  const postSystemOffset = -new Date(+date).getTimezoneOffset();\n  const postOffsetDiff = postSystemOffset - postOffset;\n  const offsetChanged = postOffset !== offset;\n  const postDiff = postOffsetDiff - offsetDiff;\n  if (offsetChanged && postDiff) {\n    Date.prototype.setUTCMinutes.call(date, Date.prototype.getUTCMinutes.call(date) + postDiff);\n\n    // Now we need to check if got offset change during the post-adjustment.\n    // If so, we also need both dates to reflect that.\n\n    const newBaseOffset = tzOffset(date.timeZone, date);\n    // Remove the seconds offset\n    // use Math.floor for negative GMT timezones and Math.ceil for positive GMT timezones.\n    const newOffset = newBaseOffset > 0 ? Math.floor(newBaseOffset) : Math.ceil(newBaseOffset);\n    const offsetChange = postOffset - newOffset;\n    if (offsetChange) {\n      date.internal.setUTCMinutes(date.internal.getUTCMinutes() + offsetChange);\n      Date.prototype.setUTCMinutes.call(date, Date.prototype.getUTCMinutes.call(date) + offsetChange);\n    }\n  }\n\n  //#endregion\n}","map":{"version":3,"names":["tzOffset","TZDateMini","Date","constructor","args","length","timeZone","pop","internal","isNaN","setTime","NaN","now","adjustToSystemTZ","syncToInternal","tz","withTimeZone","getTimezoneOffset","offset","Math","floor","ceil","time","prototype","apply","arguments","Symbol","for","date","re","Object","getOwnPropertyNames","forEach","method","test","utcMethod","replace","startsWith","syncFromInternal","setUTCSeconds","getUTCSeconds","round","setFullYear","call","getUTCFullYear","getUTCMonth","getUTCDate","setHours","getUTCHours","getUTCMinutes","getUTCMilliseconds","baseOffset","prevHour","setUTCHours","systemOffset","prevHourSystemOffset","systemDSTChange","dstShift","getHours","setUTCMinutes","offsetDiff","systemDate","systemSecondsOffset","getSeconds","secondsOffset","postBaseOffset","postOffset","postSystemOffset","postOffsetDiff","offsetChanged","postDiff","newBaseOffset","newOffset","offsetChange"],"sources":["/Users/mairaquintero/Desktop/project-salas/node_modules/@date-fns/tz/date/mini.js"],"sourcesContent":["import { tzOffset } from \"../tzOffset/index.js\";\nexport class TZDateMini extends Date {\n  //#region static\n\n  constructor(...args) {\n    super();\n    if (args.length > 1 && typeof args[args.length - 1] === \"string\") {\n      this.timeZone = args.pop();\n    }\n    this.internal = new Date();\n    if (isNaN(tzOffset(this.timeZone, this))) {\n      this.setTime(NaN);\n    } else {\n      if (!args.length) {\n        this.setTime(Date.now());\n      } else if (typeof args[0] === \"number\" && (args.length === 1 || args.length === 2 && typeof args[1] !== \"number\")) {\n        this.setTime(args[0]);\n      } else if (typeof args[0] === \"string\") {\n        this.setTime(+new Date(args[0]));\n      } else if (args[0] instanceof Date) {\n        this.setTime(+args[0]);\n      } else {\n        this.setTime(+new Date(...args));\n        adjustToSystemTZ(this, NaN);\n        syncToInternal(this);\n      }\n    }\n  }\n  static tz(tz, ...args) {\n    return args.length ? new TZDateMini(...args, tz) : new TZDateMini(Date.now(), tz);\n  }\n\n  //#endregion\n\n  //#region time zone\n\n  withTimeZone(timeZone) {\n    return new TZDateMini(+this, timeZone);\n  }\n  getTimezoneOffset() {\n    const offset = -tzOffset(this.timeZone, this);\n    // Remove the seconds offset\n    // use Math.floor for negative GMT timezones and Math.ceil for positive GMT timezones.\n    return offset > 0 ? Math.floor(offset) : Math.ceil(offset);\n  }\n\n  //#endregion\n\n  //#region time\n\n  setTime(time) {\n    Date.prototype.setTime.apply(this, arguments);\n    syncToInternal(this);\n    return +this;\n  }\n\n  //#endregion\n\n  //#region date-fns integration\n\n  [Symbol.for(\"constructDateFrom\")](date) {\n    return new TZDateMini(+new Date(date), this.timeZone);\n  }\n\n  //#endregion\n}\n\n// Assign getters and setters\nconst re = /^(get|set)(?!UTC)/;\nObject.getOwnPropertyNames(Date.prototype).forEach(method => {\n  if (!re.test(method)) return;\n  const utcMethod = method.replace(re, \"$1UTC\");\n  // Filter out methods without UTC counterparts\n  if (!TZDateMini.prototype[utcMethod]) return;\n  if (method.startsWith(\"get\")) {\n    // Delegate to internal date's UTC method\n    TZDateMini.prototype[method] = function () {\n      return this.internal[utcMethod]();\n    };\n  } else {\n    // Assign regular setter\n    TZDateMini.prototype[method] = function () {\n      Date.prototype[utcMethod].apply(this.internal, arguments);\n      syncFromInternal(this);\n      return +this;\n    };\n\n    // Assign UTC setter\n    TZDateMini.prototype[utcMethod] = function () {\n      Date.prototype[utcMethod].apply(this, arguments);\n      syncToInternal(this);\n      return +this;\n    };\n  }\n});\n\n/**\n * Function syncs time to internal date, applying the time zone offset.\n *\n * @param {Date} date - Date to sync\n */\nfunction syncToInternal(date) {\n  date.internal.setTime(+date);\n  date.internal.setUTCSeconds(date.internal.getUTCSeconds() - Math.round(-tzOffset(date.timeZone, date) * 60));\n}\n\n/**\n * Function syncs the internal date UTC values to the date. It allows to get\n * accurate timestamp value.\n *\n * @param {Date} date - The date to sync\n */\nfunction syncFromInternal(date) {\n  // First we transpose the internal values\n  Date.prototype.setFullYear.call(date, date.internal.getUTCFullYear(), date.internal.getUTCMonth(), date.internal.getUTCDate());\n  Date.prototype.setHours.call(date, date.internal.getUTCHours(), date.internal.getUTCMinutes(), date.internal.getUTCSeconds(), date.internal.getUTCMilliseconds());\n\n  // Now we have to adjust the date to the system time zone\n  adjustToSystemTZ(date);\n}\n\n/**\n * Function adjusts the date to the system time zone. It uses the time zone\n * differences to calculate the offset and adjust the date.\n *\n * @param {Date} date - Date to adjust\n */\nfunction adjustToSystemTZ(date) {\n  // Save the time zone offset before all the adjustments\n  const baseOffset = tzOffset(date.timeZone, date);\n  // Remove the seconds offset\n  // use Math.floor for negative GMT timezones and Math.ceil for positive GMT timezones.\n  const offset = baseOffset > 0 ? Math.floor(baseOffset) : Math.ceil(baseOffset);\n  //#region System DST adjustment\n\n  // The biggest problem with using the system time zone is that when we create\n  // a date from internal values stored in UTC, the system time zone might end\n  // up on the DST hour:\n  //\n  //   $ TZ=America/New_York node\n  //   > new Date(2020, 2, 8, 1).toString()\n  //   'Sun Mar 08 2020 01:00:00 GMT-0500 (Eastern Standard Time)'\n  //   > new Date(2020, 2, 8, 2).toString()\n  //   'Sun Mar 08 2020 03:00:00 GMT-0400 (Eastern Daylight Time)'\n  //   > new Date(2020, 2, 8, 3).toString()\n  //   'Sun Mar 08 2020 03:00:00 GMT-0400 (Eastern Daylight Time)'\n  //   > new Date(2020, 2, 8, 4).toString()\n  //   'Sun Mar 08 2020 04:00:00 GMT-0400 (Eastern Daylight Time)'\n  //\n  // Here we get the same hour for both 2 and 3, because the system time zone\n  // has DST beginning at 8 March 2020, 2 a.m. and jumps to 3 a.m. So we have\n  // to adjust the internal date to reflect that.\n  //\n  // However we want to adjust only if that's the DST hour the change happenes,\n  // not the hour where DST moves to.\n\n  // We calculate the previous hour to see if the time zone offset has changed\n  // and we have landed on the DST hour.\n  const prevHour = new Date(+date);\n  // We use UTC methods here as we don't want to land on the same hour again\n  // in case of DST.\n  prevHour.setUTCHours(prevHour.getUTCHours() - 1);\n\n  // Calculate if we are on the system DST hour.\n  const systemOffset = -new Date(+date).getTimezoneOffset();\n  const prevHourSystemOffset = -new Date(+prevHour).getTimezoneOffset();\n  const systemDSTChange = systemOffset - prevHourSystemOffset;\n  // Detect the DST shift. System DST change will occur both on\n  const dstShift = Date.prototype.getHours.apply(date) !== date.internal.getUTCHours();\n\n  // Move the internal date when we are on the system DST hour.\n  if (systemDSTChange && dstShift) date.internal.setUTCMinutes(date.internal.getUTCMinutes() + systemDSTChange);\n\n  //#endregion\n\n  //#region System diff adjustment\n\n  // Now we need to adjust the date, since we just applied internal values.\n  // We need to calculate the difference between the system and date time zones\n  // and apply it to the date.\n\n  const offsetDiff = systemOffset - offset;\n  if (offsetDiff) Date.prototype.setUTCMinutes.call(date, Date.prototype.getUTCMinutes.call(date) + offsetDiff);\n\n  //#endregion\n\n  //#region Seconds System diff adjustment\n\n  const systemDate = new Date(+date);\n  // Set the UTC seconds to 0 to isolate the timezone offset in seconds.\n  systemDate.setUTCSeconds(0);\n  // For negative systemOffset, invert the seconds.\n  const systemSecondsOffset = systemOffset > 0 ? systemDate.getSeconds() : (systemDate.getSeconds() - 60) % 60;\n\n  // Calculate the seconds offset based on the timezone offset.\n  const secondsOffset = Math.round(-(tzOffset(date.timeZone, date) * 60)) % 60;\n  if (secondsOffset || systemSecondsOffset) {\n    date.internal.setUTCSeconds(date.internal.getUTCSeconds() + secondsOffset);\n    Date.prototype.setUTCSeconds.call(date, Date.prototype.getUTCSeconds.call(date) + secondsOffset + systemSecondsOffset);\n  }\n\n  //#endregion\n\n  //#region Post-adjustment DST fix\n\n  const postBaseOffset = tzOffset(date.timeZone, date);\n  // Remove the seconds offset\n  // use Math.floor for negative GMT timezones and Math.ceil for positive GMT timezones.\n  const postOffset = postBaseOffset > 0 ? Math.floor(postBaseOffset) : Math.ceil(postBaseOffset);\n  const postSystemOffset = -new Date(+date).getTimezoneOffset();\n  const postOffsetDiff = postSystemOffset - postOffset;\n  const offsetChanged = postOffset !== offset;\n  const postDiff = postOffsetDiff - offsetDiff;\n  if (offsetChanged && postDiff) {\n    Date.prototype.setUTCMinutes.call(date, Date.prototype.getUTCMinutes.call(date) + postDiff);\n\n    // Now we need to check if got offset change during the post-adjustment.\n    // If so, we also need both dates to reflect that.\n\n    const newBaseOffset = tzOffset(date.timeZone, date);\n    // Remove the seconds offset\n    // use Math.floor for negative GMT timezones and Math.ceil for positive GMT timezones.\n    const newOffset = newBaseOffset > 0 ? Math.floor(newBaseOffset) : Math.ceil(newBaseOffset);\n    const offsetChange = postOffset - newOffset;\n    if (offsetChange) {\n      date.internal.setUTCMinutes(date.internal.getUTCMinutes() + offsetChange);\n      Date.prototype.setUTCMinutes.call(date, Date.prototype.getUTCMinutes.call(date) + offsetChange);\n    }\n  }\n\n  //#endregion\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}