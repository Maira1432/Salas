{"ast":null,"code":"/**\n * Calculates the next date that should be focused in the calendar.\n *\n * This function determines the next focusable date based on the movement\n * direction, constraints, and calendar configuration.\n *\n * @param moveBy The unit of movement (e.g., \"day\", \"week\").\n * @param moveDir The direction of movement (\"before\" or \"after\").\n * @param refDate The reference date from which to calculate the next focusable\n *   date.\n * @param navStart The earliest date the user can navigate to.\n * @param navEnd The latest date the user can navigate to.\n * @param props The DayPicker props, including calendar configuration options.\n * @param dateLib The date library to use for date manipulation.\n * @returns The next focusable date.\n */\nexport function getFocusableDate(moveBy, moveDir, refDate, navStart, navEnd, props, dateLib) {\n  const {\n    ISOWeek,\n    broadcastCalendar\n  } = props;\n  const {\n    addDays,\n    addMonths,\n    addWeeks,\n    addYears,\n    endOfBroadcastWeek,\n    endOfISOWeek,\n    endOfWeek,\n    max,\n    min,\n    startOfBroadcastWeek,\n    startOfISOWeek,\n    startOfWeek\n  } = dateLib;\n  const moveFns = {\n    day: addDays,\n    week: addWeeks,\n    month: addMonths,\n    year: addYears,\n    startOfWeek: date => broadcastCalendar ? startOfBroadcastWeek(date, dateLib) : ISOWeek ? startOfISOWeek(date) : startOfWeek(date),\n    endOfWeek: date => broadcastCalendar ? endOfBroadcastWeek(date) : ISOWeek ? endOfISOWeek(date) : endOfWeek(date)\n  };\n  let focusableDate = moveFns[moveBy](refDate, moveDir === \"after\" ? 1 : -1);\n  if (moveDir === \"before\" && navStart) {\n    focusableDate = max([navStart, focusableDate]);\n  } else if (moveDir === \"after\" && navEnd) {\n    focusableDate = min([navEnd, focusableDate]);\n  }\n  return focusableDate;\n}","map":{"version":3,"names":["getFocusableDate","moveBy","moveDir","refDate","navStart","navEnd","props","dateLib","ISOWeek","broadcastCalendar","addDays","addMonths","addWeeks","addYears","endOfBroadcastWeek","endOfISOWeek","endOfWeek","max","min","startOfBroadcastWeek","startOfISOWeek","startOfWeek","moveFns","day","week","month","year","date","focusableDate"],"sources":["/Users/mairaquintero/Desktop/project-salas/node_modules/react-day-picker/dist/esm/helpers/getFocusableDate.js"],"sourcesContent":["/**\n * Calculates the next date that should be focused in the calendar.\n *\n * This function determines the next focusable date based on the movement\n * direction, constraints, and calendar configuration.\n *\n * @param moveBy The unit of movement (e.g., \"day\", \"week\").\n * @param moveDir The direction of movement (\"before\" or \"after\").\n * @param refDate The reference date from which to calculate the next focusable\n *   date.\n * @param navStart The earliest date the user can navigate to.\n * @param navEnd The latest date the user can navigate to.\n * @param props The DayPicker props, including calendar configuration options.\n * @param dateLib The date library to use for date manipulation.\n * @returns The next focusable date.\n */\nexport function getFocusableDate(moveBy, moveDir, refDate, navStart, navEnd, props, dateLib) {\n    const { ISOWeek, broadcastCalendar } = props;\n    const { addDays, addMonths, addWeeks, addYears, endOfBroadcastWeek, endOfISOWeek, endOfWeek, max, min, startOfBroadcastWeek, startOfISOWeek, startOfWeek, } = dateLib;\n    const moveFns = {\n        day: addDays,\n        week: addWeeks,\n        month: addMonths,\n        year: addYears,\n        startOfWeek: (date) => broadcastCalendar\n            ? startOfBroadcastWeek(date, dateLib)\n            : ISOWeek\n                ? startOfISOWeek(date)\n                : startOfWeek(date),\n        endOfWeek: (date) => broadcastCalendar\n            ? endOfBroadcastWeek(date)\n            : ISOWeek\n                ? endOfISOWeek(date)\n                : endOfWeek(date),\n    };\n    let focusableDate = moveFns[moveBy](refDate, moveDir === \"after\" ? 1 : -1);\n    if (moveDir === \"before\" && navStart) {\n        focusableDate = max([navStart, focusableDate]);\n    }\n    else if (moveDir === \"after\" && navEnd) {\n        focusableDate = min([navEnd, focusableDate]);\n    }\n    return focusableDate;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,gBAAgBA,CAACC,MAAM,EAAEC,OAAO,EAAEC,OAAO,EAAEC,QAAQ,EAAEC,MAAM,EAAEC,KAAK,EAAEC,OAAO,EAAE;EACzF,MAAM;IAAEC,OAAO;IAAEC;EAAkB,CAAC,GAAGH,KAAK;EAC5C,MAAM;IAAEI,OAAO;IAAEC,SAAS;IAAEC,QAAQ;IAAEC,QAAQ;IAAEC,kBAAkB;IAAEC,YAAY;IAAEC,SAAS;IAAEC,GAAG;IAAEC,GAAG;IAAEC,oBAAoB;IAAEC,cAAc;IAAEC;EAAa,CAAC,GAAGd,OAAO;EACrK,MAAMe,OAAO,GAAG;IACZC,GAAG,EAAEb,OAAO;IACZc,IAAI,EAAEZ,QAAQ;IACda,KAAK,EAAEd,SAAS;IAChBe,IAAI,EAAEb,QAAQ;IACdQ,WAAW,EAAGM,IAAI,IAAKlB,iBAAiB,GAClCU,oBAAoB,CAACQ,IAAI,EAAEpB,OAAO,CAAC,GACnCC,OAAO,GACHY,cAAc,CAACO,IAAI,CAAC,GACpBN,WAAW,CAACM,IAAI,CAAC;IAC3BX,SAAS,EAAGW,IAAI,IAAKlB,iBAAiB,GAChCK,kBAAkB,CAACa,IAAI,CAAC,GACxBnB,OAAO,GACHO,YAAY,CAACY,IAAI,CAAC,GAClBX,SAAS,CAACW,IAAI;EAC5B,CAAC;EACD,IAAIC,aAAa,GAAGN,OAAO,CAACrB,MAAM,CAAC,CAACE,OAAO,EAAED,OAAO,KAAK,OAAO,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;EAC1E,IAAIA,OAAO,KAAK,QAAQ,IAAIE,QAAQ,EAAE;IAClCwB,aAAa,GAAGX,GAAG,CAAC,CAACb,QAAQ,EAAEwB,aAAa,CAAC,CAAC;EAClD,CAAC,MACI,IAAI1B,OAAO,KAAK,OAAO,IAAIG,MAAM,EAAE;IACpCuB,aAAa,GAAGV,GAAG,CAAC,CAACb,MAAM,EAAEuB,aAAa,CAAC,CAAC;EAChD;EACA,OAAOA,aAAa;AACxB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}