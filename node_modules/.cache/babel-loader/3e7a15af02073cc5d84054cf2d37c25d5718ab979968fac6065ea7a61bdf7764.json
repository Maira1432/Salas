{"ast":null,"code":"var _jsxFileName = \"/Users/mairaquintero/Desktop/project-salas/src/context/ReservationsContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport { createContext, useContext, useEffect, useMemo, useState } from \"react\";\n// IMPORTACIONES CRÍTICAS DE MSAL\nimport { msalInstance, loginRequest } from '../msalConfig';\nimport { BrowserAuthError } from '@azure/msal-browser';\n\n// --- ASUNCIONES DE UTILIDADES ---\n// (Estas utilidades deben existir en tus archivos utils)\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst initialReservations = []; // Asume que tienes un array inicial en tu utils\nconst reviveDates = arr => arr.map(r => ({\n  ...r,\n  startTime: new Date(r.startTime),\n  endTime: new Date(r.endTime)\n}));\nconst toISO = r => ({\n  ...r,\n  startTime: r.startTime.toISOString(),\n  endTime: r.endTime.toISOString()\n});\n// ------------------------------------\n\nconst ReservationsCtx = /*#__PURE__*/createContext(null);\nexport const ReservationsProvider = ({\n  children\n}) => {\n  _s();\n  const [reservations, setReservations] = useState([]);\n\n  // [Tu lógica de localStorage de useEffect está aquí]\n  useEffect(() => {\n    // ... Cargar y guardar en localStorage (omitido por espacio, asumo que funciona)\n    const seeded = initialReservations.map(toISO);\n    setReservations(reviveDates(seeded));\n  }, []);\n  useEffect(() => {\n    // ... Guardar en localStorage cada vez que cambie 'reservations'\n  }, [reservations]);\n\n  // -------------------------------------------------------------\n  // FUNCIÓN ASÍNCRONA DE CREACIÓN/ACTUALIZACIÓN (POST)\n  // -------------------------------------------------------------\n  const addOrUpdate = async reservationPayload => {\n    // 1. ADQUIRIR TOKEN SILENCIOSAMENTE (Con manejo de expiración)\n    const account = msalInstance.getActiveAccount();\n    if (!account) throw new Error(\"Debe iniciar sesión para crear una reserva.\");\n    let tokenResponse;\n    try {\n      // Intenta obtener el token\n      tokenResponse = await msalInstance.acquireTokenSilent({\n        ...loginRequest,\n        account: account\n      });\n    } catch (error) {\n      // 1. Si falla, obligamos al usuario a iniciar sesión de nuevo.\n      msalInstance.loginRedirect(loginRequest);\n\n      // 2. DETENER LA FUNCIÓN AQUÍ: Usamos 'return' para que el código no intente usar 'tokenResponse'.\n      return;\n    }\n\n    // 3. El código después de aquí (const token = tokenResponse.accessToken;) AHORA ESTÁ SEGURO.\n\n    const token = tokenResponse.accessToken;\n\n    // 2. LLAMAR A MICROSOFT GRAPH (POST)\n    const event = {\n      subject: reservationPayload.title,\n      start: {\n        dateTime: reservationPayload.startTime,\n        timeZone: \"America/Bogota\"\n      },\n      end: {\n        dateTime: reservationPayload.endTime,\n        timeZone: \"America/Bogota\"\n      },\n      attendees: [{\n        emailAddress: {\n          address: reservationPayload.roomEmail,\n          name: reservationPayload.room.nombre\n        },\n        type: \"resource\"\n      }]\n    };\n    const response = await fetch('https://graph.microsoft.com/v1.0/me/events', {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${token}`,\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(event)\n    });\n    if (!response.ok) {\n      const errorData = await response.json();\n      console.error(\"Error Graph API:\", errorData);\n      throw new Error(`Error al guardar: ${errorData.error.message}`);\n    }\n    const apiResponse = await response.json();\n\n    // 3. ACTUALIZAR ESTADO LOCAL con la respuesta real de la API\n    setReservations(prev => {\n      // A. Tomamos el objeto original del formulario (¡que sí tiene el campo room.nombre!)\n      const baseReservation = {\n        ...reservationPayload\n      };\n\n      // B. Sobreescribimos el ID y las fechas con los valores oficiales de Microsoft\n      baseReservation.id = apiResponse.id; // <-- Usamos el ID real que Outlook creó\n      baseReservation.startTime = apiResponse.start.dateTime; // Fechas confirmadas por la API\n      baseReservation.endTime = apiResponse.end.dateTime;\n\n      // C. Creamos el objeto final con las fechas convertidas a objetos Date\n      const newReservation = reviveDates([baseReservation])[0];\n\n      // D. Actualizamos la lista\n      const others = prev.filter(x => x.id !== newReservation.id);\n      return [newReservation, ...others];\n    });\n  };\n\n  // -------------------------------------------------------------\n  // FUNCIÓN ASÍNCRONA DE ELIMINACIÓN (DELETE)\n  // -------------------------------------------------------------\n  const removeById = async reservationId => {\n    const account = msalInstance.getActiveAccount();\n    if (!account) throw new Error(\"Debe iniciar sesión para eliminar una reserva.\");\n    const tokenResponse = await msalInstance.acquireTokenSilent({\n      ...loginRequest,\n      account: account\n    });\n    const token = tokenResponse.accessToken;\n    const response = await fetch(`https://graph.microsoft.com/v1.0/me/events/${reservationId}`, {\n      method: 'DELETE',\n      headers: {\n        'Authorization': `Bearer ${token}`\n      }\n    });\n    if (!response.ok) {\n      throw new Error(`Error al eliminar: ${response.statusText}`);\n    }\n\n    // Si el DELETE fue exitoso (204 No Content), actualizamos el estado local\n    setReservations(prev => prev.filter(r => r.id !== reservationId));\n  };\n\n  // -------------------------------------------------------------\n\n  const value = useMemo(() => ({\n    reservations,\n    addOrUpdate,\n    removeById\n  }), [reservations]);\n  return /*#__PURE__*/_jsxDEV(ReservationsCtx.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 141,\n    columnNumber: 12\n  }, this);\n};\n_s(ReservationsProvider, \"WrTqYW4gbH5IffQStdXGbjG1i4U=\");\n_c = ReservationsProvider;\nexport const useReservations = () => {\n  _s2();\n  const ctx = useContext(ReservationsCtx);\n  if (!ctx) throw new Error(\"useReservations debe usarse dentro de <ReservationsProvider>\");\n  return ctx;\n};\n_s2(useReservations, \"/dMy7t63NXD4eYACoT93CePwGrg=\");\nvar _c;\n$RefreshReg$(_c, \"ReservationsProvider\");","map":{"version":3,"names":["createContext","useContext","useEffect","useMemo","useState","msalInstance","loginRequest","BrowserAuthError","jsxDEV","_jsxDEV","initialReservations","reviveDates","arr","map","r","startTime","Date","endTime","toISO","toISOString","ReservationsCtx","ReservationsProvider","children","_s","reservations","setReservations","seeded","addOrUpdate","reservationPayload","account","getActiveAccount","Error","tokenResponse","acquireTokenSilent","error","loginRedirect","token","accessToken","event","subject","title","start","dateTime","timeZone","end","attendees","emailAddress","address","roomEmail","name","room","nombre","type","response","fetch","method","headers","body","JSON","stringify","ok","errorData","json","console","message","apiResponse","prev","baseReservation","id","newReservation","others","filter","x","removeById","reservationId","statusText","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","useReservations","_s2","ctx","$RefreshReg$"],"sources":["/Users/mairaquintero/Desktop/project-salas/src/context/ReservationsContext.js"],"sourcesContent":["import { createContext, useContext, useEffect, useMemo, useState } from \"react\";\n// IMPORTACIONES CRÍTICAS DE MSAL\nimport { msalInstance, loginRequest } from '../msalConfig';\nimport { BrowserAuthError } from '@azure/msal-browser';\n\n// --- ASUNCIONES DE UTILIDADES ---\n// (Estas utilidades deben existir en tus archivos utils)\nconst initialReservations = []; // Asume que tienes un array inicial en tu utils\nconst reviveDates = (arr) => arr.map(r => ({\n    ...r,\n    startTime: new Date(r.startTime),\n    endTime: new Date(r.endTime),\n}));\nconst toISO = (r) => ({\n    ...r,\n    startTime: r.startTime.toISOString(),\n    endTime: r.endTime.toISOString(),\n});\n// ------------------------------------\n\nconst ReservationsCtx = createContext(null);\n\nexport const ReservationsProvider = ({ children }) => {\n    const [reservations, setReservations] = useState([]);\n\n    // [Tu lógica de localStorage de useEffect está aquí]\n    useEffect(() => {\n        // ... Cargar y guardar en localStorage (omitido por espacio, asumo que funciona)\n        const seeded = initialReservations.map(toISO);\n        setReservations(reviveDates(seeded));\n    }, []);\n\n    useEffect(() => {\n        // ... Guardar en localStorage cada vez que cambie 'reservations'\n    }, [reservations]);\n\n\n    // -------------------------------------------------------------\n    // FUNCIÓN ASÍNCRONA DE CREACIÓN/ACTUALIZACIÓN (POST)\n    // -------------------------------------------------------------\n    const addOrUpdate = async (reservationPayload) => {\n        \n        // 1. ADQUIRIR TOKEN SILENCIOSAMENTE (Con manejo de expiración)\n        const account = msalInstance.getActiveAccount();\n        if (!account) throw new Error(\"Debe iniciar sesión para crear una reserva.\");\n\n      let tokenResponse; \n        try {\n            // Intenta obtener el token\n            tokenResponse = await msalInstance.acquireTokenSilent({\n                ...loginRequest,\n                account: account\n            });\n        } catch (error) {\n            // 1. Si falla, obligamos al usuario a iniciar sesión de nuevo.\n            msalInstance.loginRedirect(loginRequest); \n            \n            // 2. DETENER LA FUNCIÓN AQUÍ: Usamos 'return' para que el código no intente usar 'tokenResponse'.\n            return; \n        }\n        \n        // 3. El código después de aquí (const token = tokenResponse.accessToken;) AHORA ESTÁ SEGURO.\n\n        const token = tokenResponse.accessToken;\n\n        // 2. LLAMAR A MICROSOFT GRAPH (POST)\n        const event = {\n            subject: reservationPayload.title,\n            start: { dateTime: reservationPayload.startTime, timeZone: \"America/Bogota\" },\n            end: { dateTime: reservationPayload.endTime, timeZone: \"America/Bogota\" },\n            attendees: [{\n                emailAddress: { address: reservationPayload.roomEmail, name: reservationPayload.room.nombre },\n                type: \"resource\"\n            }],\n        };\n        \n        const response = await fetch('https://graph.microsoft.com/v1.0/me/events', {\n            method: 'POST',\n            headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },\n            body: JSON.stringify(event)\n        });\n\n        if (!response.ok) {\n            const errorData = await response.json();\n            console.error(\"Error Graph API:\", errorData);\n            throw new Error(`Error al guardar: ${errorData.error.message}`);\n        }\n\n        const apiResponse = await response.json();\n\n        // 3. ACTUALIZAR ESTADO LOCAL con la respuesta real de la API\n        setReservations(prev => {\n            \n            // A. Tomamos el objeto original del formulario (¡que sí tiene el campo room.nombre!)\n            const baseReservation = { ...reservationPayload }; \n            \n            // B. Sobreescribimos el ID y las fechas con los valores oficiales de Microsoft\n            baseReservation.id = apiResponse.id; // <-- Usamos el ID real que Outlook creó\n            baseReservation.startTime = apiResponse.start.dateTime; // Fechas confirmadas por la API\n            baseReservation.endTime = apiResponse.end.dateTime;\n\n            // C. Creamos el objeto final con las fechas convertidas a objetos Date\n            const newReservation = reviveDates([baseReservation])[0];\n            \n            // D. Actualizamos la lista\n            const others = prev.filter(x => x.id !== newReservation.id);\n            return [newReservation, ...others];\n        });\n    };\n    \n    // -------------------------------------------------------------\n    // FUNCIÓN ASÍNCRONA DE ELIMINACIÓN (DELETE)\n    // -------------------------------------------------------------\n    const removeById = async (reservationId) => {\n        const account = msalInstance.getActiveAccount();\n        if (!account) throw new Error(\"Debe iniciar sesión para eliminar una reserva.\");\n\n        const tokenResponse = await msalInstance.acquireTokenSilent({\n            ...loginRequest,\n            account: account\n        });\n        const token = tokenResponse.accessToken;\n        \n        const response = await fetch(`https://graph.microsoft.com/v1.0/me/events/${reservationId}`, {\n            method: 'DELETE',\n            headers: { 'Authorization': `Bearer ${token}` }\n        });\n\n        if (!response.ok) {\n            throw new Error(`Error al eliminar: ${response.statusText}`);\n        }\n\n        // Si el DELETE fue exitoso (204 No Content), actualizamos el estado local\n        setReservations(prev => prev.filter(r => r.id !== reservationId));\n    };\n    \n    // -------------------------------------------------------------\n\n    const value = useMemo(() => ({ reservations, addOrUpdate, removeById }), [reservations]);\n\n    return <ReservationsCtx.Provider value={value}>{children}</ReservationsCtx.Provider>;\n};\n\nexport const useReservations = () => {\n    const ctx = useContext(ReservationsCtx);\n    if (!ctx) throw new Error(\"useReservations debe usarse dentro de <ReservationsProvider>\");\n    return ctx;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}